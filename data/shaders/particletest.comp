
layout(local_size_x = PARTICLE_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = BINDING_SSBO_POSITION) buffer PositionBuffer
{
	vec3 pos[];
};

layout(std430, binding = BINDING_SSBO_VELOCITY) buffer VelocityBuffer
{
	vec3 vel[];
};

layout(std430, binding = BINDING_SSBO_LIFE) buffer LifeBuffer
{
	vec2 life[];
};

float rand(vec2 seed) {
	return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 randVec(float seed) {
	return vec3(rand(vec2(seed, 1)), rand(vec2(seed, 2.3)), rand(vec2(seed, 3.1))) * vec3(2.0) - vec3(1.0);
}

vec3 randDir(float seed) {
	return normalize(randVec(seed));
}

const float G = 0.3;
const float Radius = 1.0;
const float MaxLife = 5.0;

void main()
{
	uint index = gl_GlobalInvocationID.x;
	if (life[index].x <= 0.0) {
		float seed = float(index) * dt + sin(time);
		life[index].x = max(MaxLife * rand(vec2(seed, 3.4)), 0.001);
		life[index].y = life[index].x; // Original max life
		// Pick position inside a sphere
		pos[index] = randDir(seed) * (0.5 + rand(vec2(seed, 1.267) * 0.5)) * Radius;
		// Try to find velocity somewhat perpendicular to the center
		vec3 dir = normalize(pos[index]);
		vel[index] = cross(-dir, randDir(seed * 0.345)) * 0.5 + dir * 0.5;
	} else {
		life[index].x = max(life[index].x - dt, 0.0);
		pos[index] += vel[index] * dt;
		vec3 acc = -normalize(pos[index]) * (G / length(pos[index]));
		vel[index] += acc * dt;
	}
}
